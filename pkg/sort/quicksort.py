# coding=utf-8
# 快排：
# 思想：递归遍历数组「寻找基准位」的过程，每次递归找到基准位mid，让基准位左边的数字都小于基准位数字，基准位右边的数字都大于基准位数字；再分别递归排序基准位左边的数组和基准位右边的数组，直到左边和右边都排列有序。
# 一次遍历排序过程：
# 假设基准为数组起始位置，首先记录下基准位的数字 mid 和 值 tmp（过程中 mid 会变化，所以要记录初始值 tmp）；
# 双指针遍历法：i 指向数组最左端，j 指向数组最右端；让 j 从最右边开始移动，直到遇到第一个小于 tmp 的位置停下，此时把 j 的值填到 mid 的位置；
# 再让 i 从最左边开始移动，直到遇到第一个元素大于 tmp 的位置停下，此时把 i 的值填到 j 的位置（如果i不等于j），mid 等于 i；直到 i 和 j 相遇，把 tmp 填到 mid 的位置。
# 循环结束的条件：头尾指针相遇，相遇位置即基准位置；递归结束的条件：数组元素为1。
# 时间复杂度：一次遍历需要O(N)时间，递归深度 O(logN)，总共需要 O(NlogN) 时间复杂度；排序过程中无法保证相等元素相对位置，是不稳定的排序算法。

def test(li1, start, end):
    # 递归结束的条件：数组只有一个元素
    if start >= end:
        return
    mid = start
    tmp = li1[mid]
    # i和j:头尾指针，移动的是i 和 j，不是 start 和 end
    i = start
    j = end
    # 循环结束的条件，i遇到j，即基准位
    while i < j:
        # j 移动到第一个比 tmp小的元素位置停下；把 j 的值填到 mid
        while i < j and li1[j] >= tmp:
            j -= 1
        li1[mid] = li1[j]
        # i 移动到第一个比 tmp大的元素位置停下，把 i 的值填到 j 的位置，把 tmp 跳到 i 的位置
        while i < j and li1[i] <= tmp:
            i += 1
        if i != j:
            li1[j] = li1[i]
        mid = i
    li1[mid] = tmp
    test(li1, start, mid - 1)
    test(li1, mid + 1, end)


if __name__ == '__main__':
    a = [0, 1, 2, 5, 7, 3, 3, 4]
    test(a, 0, len(a) - 1)
    print a


# 分析：
# mid=0，tmp = 5，j=4，i=0
# 5, 7, 3, 3, 4
# j = 4
# 4, 7, 3, 3, 4
# i = 1，mid = 1
# 4, 7, 3, 3, 7
# j = 3
# 4, 3, 3, 3, 7
# i = 3，mid = 3，遍历结束：把 5 填到 mid 的位置
# 4, 3, 3, 5, 7

