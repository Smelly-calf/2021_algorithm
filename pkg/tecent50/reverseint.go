package main

import "fmt"

// Easy - 32位整数反转（系统环境不允许存储64位整数）
// 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
// 条件：假设环境不允许存储 64 位整数（有符号或无符号），如果x不属于[−2^31,  2^31 − 1]，返回0。

// 类型：整数运算，注意整数溢出。

// 思路：一个循环，每次取模运算拿末尾数字，终止条件是x=0。考虑整数的溢出，可能产生溢出的步骤在于推入rx时，判断溢出使用INT_MAX的逆操作，即推入前和 INT_MAX/10 比较。
// 提示：32位整数范围：[−2^31,  2^31 − 1]，即[-2147483648, 2147483647]

// 详细题解：
// 设内存可以存储的最大数 max=2147483647, 最小数 min=-2147483648，反转后的数字为 rx。
// 每一次循环中判断：
// 如果x为正数，rx 大于 max/10（214748364），则肯定溢出，返回0；如果 rx 等于 max/10，如果x的末尾数字大于max末尾数字7，则溢出。
// 如果x为负数，则当 rx 小于 min/10（-214748364），则肯定溢出；如果 rx 等于 min/10，如果x的末尾数字小于8，则溢出。

// 优化：32位 2以上开头的都输入不进来，因此末尾一定小于7和8，因此可以去掉 rx等于max/10和min/10的情况。

// 时间复杂度：O(log|x|)。翻转的次数即 x 十进制的位数。
// 空间复杂度： O(1)
func reverse(x int) int {
	IntMIN := -2 << 30
	IntMAX := 2<<30 - 1
	var rx int
	for x != 0 { //终止条件 x=0
		// 分成正数和负数更清晰, x%10可以先用tmp存起来
		tmp := x % 10 // tmp为每次取到的末尾数字
		// 正数
		if rx > IntMAX/10 || (rx == IntMAX/10 && tmp > 7) {
			return 0
		}
		// 负数
		if rx < IntMIN/10 && (rx == IntMIN/10 && tmp < 8) {
			return 0
		}
		rx = rx*10 + tmp // rx加的时候需要先乘以10
		x = x / 10       // x除以10
	}
	return rx
}

func main() {
	x := 1147483649
	x1 := 123
	x2 := -123
	x3 := 120
	x4 := 0
	fmt.Println(reverse(x)) //预期:0
	fmt.Println(reverse(x1))
	fmt.Println(reverse(x2))
	fmt.Println(reverse(x3))
	fmt.Println(reverse(x4))
}
